// Code generated by the Lingua Franca compiler from:
// file://home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf
#define LOG_LEVEL 2
#define TARGET_FILES_DIRECTORY "/home/fred/Lingua_Franca/Recover/Multi_input_FL/src-gen/node_net"
#define _LF_GARBAGE_COLLECTED
#include "include/ctarget/ctarget.h"
#include "core/reactor.c"
#include "core/mixed_radix.h"
#include "pythontarget.c"
int main(int argc, char* argv[]) {
    return lf_reactor_c_main(argc, argv);
}
char* _lf_default_argv[] = { "dummy", "-f", "true", "-o", "10", "sec" };
void _lf_set_default_command_line_options() {
        default_argc = 6;
        default_argv = _lf_default_argv;
}
// =============== START reactor class Node
#line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
typedef generic_port_instance_struct node_rx_t;
#line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
typedef generic_port_instance_struct node_tx_t;
typedef struct {
    struct self_base_t base;
    char *_lf_name;
    PyObject* _lf_py_reaction_function_0;
    PyObject* _lf_py_reaction_function_1;
    PyObject* _lf_py_reaction_function_2;
    #line 12 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* num_nodes;
    #line 12 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* xi;
    #line 12 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* yi;
    #line 12 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* bank_index;
    #line 25 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* a;
    #line 26 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* wf;
    #line 27 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* rsc;
    #line 28 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* x;
    #line 29 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* y;
    #line 30 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* index;
    #line 31 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    PyObject* k;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Multiport input array will be malloc'd later.
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    node_rx_t** _lf_rx;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    int _lf_rx_width;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Default input (in case it does not get connected)
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    node_rx_t _lf_default__rx;
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Array of output ports.
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    node_tx_t* _lf_tx;
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    int _lf_tx_width;
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // An array of pointers to the individual ports. Useful
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // for the lf_set macros to work out-of-the-box for
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // multiports in the body of reactions because their 
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // value can be accessed via a -> operator (e.g.,foo[i]->value).
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // So we have to handle multiports specially here a construct that
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // array of pointers.
    #line 23 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    node_tx_t** _lf_tx_pointers;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    reaction_t _lf__reaction_0;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    reaction_t _lf__reaction_1;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    reaction_t _lf__reaction_2;
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    trigger_t _lf__step;
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    reaction_t* _lf__step_reactions[1];
    trigger_t _lf__startup;
    reaction_t* _lf__startup_reactions[1];
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    trigger_t _lf__rx;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    reaction_t* _lf__rx_reactions[1];
} node_self_t;
#include "include/ctarget/set.h"
void nodereaction_function_0(void* instance_args){
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    node_self_t* self = (node_self_t*)instance_args;
    #pragma GCC diagnostic pop
    #line 34 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_0");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_0, 
        Py_BuildValue("()")
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_0 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void nodereaction_function_1(void* instance_args){
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    node_self_t* self = (node_self_t*)instance_args;
    int tx_width = self->_lf_tx_width;
    node_tx_t** tx = self->_lf_tx_pointers;
    #pragma GCC diagnostic pop
    #line 45 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_1");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_1, 
        Py_BuildValue("(O)", convert_C_port_to_py(tx, tx_width))
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_1 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/ctarget/set_undef.h"
#include "include/ctarget/set.h"
void nodereaction_function_2(void* instance_args){
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    node_self_t* self = (node_self_t*)instance_args;
    node_rx_t** rx = self->_lf_rx;
    int rx_width = self->_lf_rx_width;
    #pragma GCC diagnostic pop
    #line 56 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_2");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_2, 
        Py_BuildValue("(O)", convert_C_port_to_py(rx, rx_width))
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_2 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/ctarget/set_undef.h"
node_self_t* new_Node() {
    node_self_t* self = (node_self_t*)_lf_new_reactor(sizeof(node_self_t));
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.number = 0;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.function = nodereaction_function_0;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.self = self;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.STP_handler = NULL;
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.name = "?";
    #line 33 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_0.mode = NULL;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.number = 1;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.function = nodereaction_function_1;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.self = self;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.STP_handler = NULL;
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.name = "?";
    #line 44 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_1.mode = NULL;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.number = 2;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.function = nodereaction_function_2;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.self = self;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.STP_handler = NULL;
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.name = "?";
    #line 55 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__reaction_2.mode = NULL;
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__step.last = NULL;
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__step_reactions[0] = &self->_lf__reaction_1;
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__step.reactions = &self->_lf__step_reactions[0];
    #line 21 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__step.number_of_reactions = 1;
    self->_lf__step.is_timer = true;
    self->_lf__startup_reactions[0] = &self->_lf__reaction_0;
    self->_lf__startup.last = NULL;
    self->_lf__startup.reactions = &self->_lf__startup_reactions[0];
    self->_lf__startup.number_of_reactions = 1;
    self->_lf__startup.is_timer = false;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__rx.last = NULL;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__rx_reactions[0] = &self->_lf__reaction_2;
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__rx.reactions = &self->_lf__rx_reactions[0];
    #line 22 "file:/home/fred/Lingua_Franca/Recover/Multi_input_FL/node_net.lf"
    self->_lf__rx.number_of_reactions = 1;
    self->_lf__rx.element_size = sizeof(PyObject);
    return self;
}
// =============== END reactor class Node
// =============== START reactor class node_net
typedef struct {
    struct self_base_t base;
    char *_lf_name;
} node_net_self_t;
node_net_self_t* new_node_net() {
    node_net_self_t* self = (node_net_self_t*)_lf_new_reactor(sizeof(node_net_self_t));
    return self;
}
// =============== END reactor class node_net
// Array of pointers to timer triggers to be scheduled in _lf_initialize_timers().
trigger_t* _lf_timer_triggers[6];
int _lf_timer_triggers_size = 6;
// Array of pointers to startup triggers.
reaction_t* _lf_startup_reactions[6];
int _lf_startup_reactions_size = 6;
// Array of pointers to shutdown triggers.
reaction_t** _lf_shutdown_reactions = NULL;
int _lf_shutdown_reactions_size = 0;
// Array of pointers to reset triggers.
reaction_t** _lf_reset_reactions = NULL;
int _lf_reset_reactions_size = 0;
trigger_t* _lf_action_for_port(int port_id) {
        return NULL;
}
void _lf_initialize_trigger_objects() {
    // Initialize the _lf_clock
    lf_initialize_clock();
    // Create the array that will contain pointers to is_present fields to reset on each step.
    _lf_is_present_fields_size = 36;
    _lf_is_present_fields = (bool**)calloc(36, sizeof(bool*));
    if (_lf_is_present_fields == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated = (bool**)calloc(36, sizeof(bool*));
    if (_lf_is_present_fields_abbreviated == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated_size = 0;
    int _lf_startup_reactions_count = 0;
    int _lf_shutdown_reactions_count = 0;
    int _lf_reset_reactions_count = 0;
    int _lf_timer_triggers_count = 0;
    int _lf_tokens_with_ref_count_count = 0;
    node_net_self_t* node_net_self[1];
    node_self_t* node_net_nodes_self[6];
    // ***** Start initializing node_net of class node_net
    node_net_self[0] = new_node_net();
    node_net_self[0]->_lf_name = "node_net_lf";
    // Reactor is a bank. Iterate over bank members.
    for (int node_net_nodes_i = 0; node_net_nodes_i < 6; node_net_nodes_i++) {
        // ***** Start initializing node_net.nodes of class Node
        node_net_nodes_self[node_net_nodes_i] = new_Node();
        node_net_nodes_self[node_net_nodes_i]->_lf_name = "node_net_nodes_lf";
        node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_0 = 
        get_python_function("__main__", 
            node_net_nodes_self[node_net_nodes_i]->_lf_name,
            node_net_nodes_i,
            "reaction_function_0");
        if(node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_0 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_0");
        }
        node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_1 = 
        get_python_function("__main__", 
            node_net_nodes_self[node_net_nodes_i]->_lf_name,
            node_net_nodes_i,
            "reaction_function_1");
        if(node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_1 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_1");
        }
        node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_2 = 
        get_python_function("__main__", 
            node_net_nodes_self[node_net_nodes_i]->_lf_name,
            node_net_nodes_i,
            "reaction_function_2");
        if(node_net_nodes_self[node_net_nodes_i]->_lf_py_reaction_function_2 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_2");
        }
        node_net_nodes_self[node_net_nodes_i]->_lf_tx_width = 6;
        // Allocate memory for multiport output.
        node_net_nodes_self[node_net_nodes_i]->_lf_tx = (node_tx_t*)_lf_allocate(
                6, sizeof(node_tx_t),
                &node_net_nodes_self[node_net_nodes_i]->base.allocations); 
        node_net_nodes_self[node_net_nodes_i]->_lf_tx_pointers = (node_tx_t**)_lf_allocate(
                6, sizeof(node_tx_t*),
                &node_net_nodes_self[node_net_nodes_i]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 6; i++) {
                node_net_nodes_self[node_net_nodes_i]->_lf_tx_pointers[i] = &(node_net_nodes_self[node_net_nodes_i]->_lf_tx[i]);
        }
        node_net_nodes_self[node_net_nodes_i]->_lf_rx_width = 6;
        // Allocate memory for multiport inputs.
        node_net_nodes_self[node_net_nodes_i]->_lf_rx = (node_rx_t**)_lf_allocate(
                6, sizeof(node_rx_t*),
                &node_net_nodes_self[node_net_nodes_i]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            node_net_nodes_self[node_net_nodes_i]->_lf_rx[i] = &node_net_nodes_self[node_net_nodes_i]->_lf_default__rx;
        }
        _lf_startup_reactions[_lf_startup_reactions_count++] = &node_net_nodes_self[node_net_nodes_i]->_lf__reaction_0;
        // Initializing timer node_net.nodes.step.
        node_net_nodes_self[node_net_nodes_i]->_lf__step.offset = 0;
        node_net_nodes_self[node_net_nodes_i]->_lf__step.period = SEC(1);
        _lf_timer_triggers[_lf_timer_triggers_count++] = &node_net_nodes_self[node_net_nodes_i]->_lf__step;
        node_net_nodes_self[node_net_nodes_i]->_lf__step.mode = NULL;
        node_net_nodes_self[node_net_nodes_i]->_lf__reaction_0.deadline = NEVER;
        node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.deadline = NEVER;
        node_net_nodes_self[node_net_nodes_i]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing node_net.nodes
    }
    //***** End initializing node_net
    // **** Start deferred initialize for node_net
    {
        // **** Start deferred initialize for node_net.nodes
        // Reactor is a bank. Iterate over bank members.
        for (int node_net_nodes_i = 0; node_net_nodes_i < 6; node_net_nodes_i++) {
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of node_net.nodes.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 0 of node_net.nodes
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of node_net.nodes.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.num_outputs = 6;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.triggers = (trigger_t***)_lf_allocate(
                    6, sizeof(trigger_t**),
                    &node_net_nodes_self[node_net_nodes_i]->base.allocations);
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.triggered_sizes = (int*)_lf_allocate(
                    6, sizeof(int),
                    &node_net_nodes_self[node_net_nodes_i]->base.allocations);
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.output_produced = (bool**)_lf_allocate(
                    6, sizeof(bool*),
                    &node_net_nodes_self[node_net_nodes_i]->base.allocations);
            {
                int count = 0;
                {
                    for (int i = 0; i < 6; i++) {
                        node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.output_produced[i + count]
                                = &node_net_nodes_self[node_net_nodes_i]->_lf_tx[i].is_present;
                    }
                    count += 6;
                }
            }
            
            // ** End initialization for reaction 1 of node_net.nodes
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of node_net.nodes.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 2 of node_net.nodes
        }
        // **** End of deferred initialize for node_net.nodes
    }
    // **** End of deferred initialize for node_net
    // **** Start non-nested deferred initialize for node_net
    // **** Start non-nested deferred initialize for node_net.nodes
    // For reference counting, set num_destinations for port node_net.nodes.tx.
    // Iterate over range node_net.nodes.tx(0,36)->[node_net.nodes.rx(0,36)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 6, 6 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 36; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            node_net_nodes_self[src_runtime]->_lf_tx[src_channel].num_destinations = 6;
            mixed_radix_incr(&range_mr);
        }
    }
    {
        int triggers_index[6] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range node_net.nodes.tx(0,36)->[node_net.nodes.rx(0,36)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 6 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 36; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 1 of node_net.nodes triggers 1 downstream reactions
                // through port node_net.nodes.tx.
                node_net_nodes_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of node_net.nodes, allocate an
                // array of trigger pointers for downstream reactions through port node_net.nodes.tx
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &node_net_nodes_self[src_runtime]->base.allocations); 
                node_net_nodes_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 6; i++) triggers_index[i] = 0;
        // Iterate over ranges node_net.nodes.tx(0,36)->[node_net.nodes.rx(0,36)] and node_net.nodes.rx(0,36).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 6, 6 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range node_net.nodes.rx(0,36).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 6 };
                int permutation[] = { 1, 0 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 36; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port node_net.nodes.rx's trigger struct.
                    node_net_nodes_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &node_net_nodes_self[dst_runtime]->_lf__rx;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 36) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    // **** End of non-nested deferred initialize for node_net.nodes
    // **** End of non-nested deferred initialize for node_net
    // Connect inputs and outputs for reactor node_net.
    // Connect inputs and outputs for reactor node_net.nodes.
    // Connect node_net.nodes.tx(0,36)->[node_net.nodes.rx(0,36)] to port node_net.nodes.rx(0,36)
    // Iterate over ranges node_net.nodes.tx(0,36)->[node_net.nodes.rx(0,36)] and node_net.nodes.rx(0,36).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 6 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range node_net.nodes.rx(0,36).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 6 };
            int permutation[] = { 1, 0 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 36; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                node_net_nodes_self[dst_runtime]->_lf_rx[dst_channel] = (node_rx_t*)&node_net_nodes_self[src_runtime]->_lf_tx[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 36) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Reactor is a bank. Iterate over bank members.
    for (int node_net_nodes_i = 0; node_net_nodes_i < 6; node_net_nodes_i++) {
    }
    {
        int count = 0;
        // Reactor is a bank. Iterate over bank members.
        for (int node_net_nodes_i = 0; node_net_nodes_i < 6; node_net_nodes_i++) {
            // Add port node_net.nodes.tx to array of is_present fields.
            // Port node_net.nodes.tx is a multiport. Iterate over its channels.
            for (int node_net_nodes_tx_c = 0; node_net_nodes_tx_c < 6; node_net_nodes_tx_c++) {
                _lf_is_present_fields[0 + count] = &node_net_nodes_self[node_net_nodes_i]->_lf_tx[node_net_nodes_tx_c].is_present;
                count++;
            }
        }
    }
    // Set reaction priorities for ReactorInstance node_net
    {
        // Set reaction priorities for ReactorInstance node_net.nodes
        // Reactor is a bank. Iterate over bank members.
        for (int node_net_nodes_i = 0; node_net_nodes_i < 6; node_net_nodes_i++) {
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 140737488355327 shifted left 16 bits.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_0.index = 0x7fffffffffff0000LL;
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 1 and 
            // deadline 140737488355327 shifted left 16 bits.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_1.index = 0x7fffffffffff0001LL;
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 140737488355327 shifted left 16 bits.
            node_net_nodes_self[node_net_nodes_i]->_lf__reaction_2.index = 0x7fffffffffff0002LL;
        }
    }
}
void _lf_trigger_startup_reactions() {
    for (int i = 0; i < _lf_startup_reactions_size; i++) {
        if (_lf_startup_reactions[i] != NULL) {
            _lf_trigger_reaction(_lf_startup_reactions[i], -1);
        }
    }
}
void _lf_initialize_timers() {
    for (int i = 0; i < _lf_timer_triggers_size; i++) {
        if (_lf_timer_triggers[i] != NULL) {
            _lf_initialize_timer(_lf_timer_triggers[i]);
        }
    }

}
void logical_tag_complete(tag_t tag_to_send) {

}
bool _lf_trigger_shutdown_reactions() {
    return false;
}
void terminate_execution() {}
