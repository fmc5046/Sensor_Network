// Code generated by the Lingua Franca compiler from:
// file://home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf
#define LOG_LEVEL 2
#define TARGET_FILES_DIRECTORY "/home/fred/Lingua_Franca/Recover/Multi_input_FL/src-gen/mi"
#include "include/api/api.h"
#include "core/reactor.h"
#include "core/reactor_common.h"
#include "core/mixed_radix.h"
#include "core/port.h"
int lf_reactor_c_main(int argc, const char* argv[]);
#include "pythontarget.h"
int main(int argc, const char* argv[]) {
    return lf_reactor_c_main(argc, argv);
}
const char* _lf_default_argv[] = { "dummy", "-f", "true", "-o", "10", "sec" };
void _lf_set_default_command_line_options() {
        default_argc = 6;
        default_argv = _lf_default_argv;
}
// =============== START reactor class Node
#line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
typedef generic_port_instance_struct node_rx_t;
#line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
typedef generic_port_instance_struct node_tx_t;
typedef struct {
    struct self_base_t base;
    char *_lf_name;
    PyObject* _lf_py_reaction_function_0;
    PyObject* _lf_py_reaction_function_1;
    PyObject* _lf_py_reaction_function_2;
    #line 12 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* num_nodes;
    #line 12 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* xi;
    #line 12 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* yi;
    #line 12 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* bank_index;
    #line 25 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* a;
    #line 26 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* wf;
    #line 27 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* rsc;
    #line 28 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* x;
    #line 29 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* y;
    #line 30 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* index;
    #line 31 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    PyObject* k;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Multiport input array will be malloc'd later.
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    node_rx_t** _lf_rx;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    int _lf_rx_width;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Default input (in case it does not get connected)
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    node_rx_t _lf_default__rx;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Struct to support efficiently reading sparse inputs.
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    lf_sparse_io_record_t* _lf_rx__sparse;
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Array of output ports.
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    node_tx_t* _lf_tx;
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    int _lf_tx_width;
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // An array of pointers to the individual ports. Useful
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // for the lf_set macros to work out-of-the-box for
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // multiports in the body of reactions because their 
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // value can be accessed via a -> operator (e.g.,foo[i]->value).
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // So we have to handle multiports specially here a construct that
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // array of pointers.
    #line 23 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    node_tx_t** _lf_tx_pointers;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    reaction_t _lf__reaction_0;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    reaction_t _lf__reaction_1;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    reaction_t _lf__reaction_2;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    trigger_t _lf__step;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    reaction_t* _lf__step_reactions[1];
    trigger_t _lf__startup;
    reaction_t* _lf__startup_reactions[1];
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    trigger_t _lf__rx;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    reaction_t* _lf__rx_reactions[1];
    #ifdef FEDERATED
    trigger_t* _lf__rx_network_port_status;
    
    #endif // FEDERATED
} node_self_t;
#include "include/api/set.h"
void nodereaction_function_0(void* instance_args){
    node_self_t* self = (node_self_t*)instance_args; SUPPRESS_UNUSED_WARNING(self);
    #line 34 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_0");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_0, 
        Py_BuildValue("()")
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_0 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/api/set_undef.h"
#include "include/api/set.h"
void nodereaction_function_1(void* instance_args){
    node_self_t* self = (node_self_t*)instance_args; SUPPRESS_UNUSED_WARNING(self);
    int tx_width = self->_lf_tx_width; SUPPRESS_UNUSED_WARNING(tx_width);
    node_tx_t** tx = self->_lf_tx_pointers;
    #line 45 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_1");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_1, 
        Py_BuildValue("(O)", convert_C_port_to_py(tx, tx_width))
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_1 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/api/set_undef.h"
#include "include/api/set.h"
void nodereaction_function_2(void* instance_args){
    node_self_t* self = (node_self_t*)instance_args; SUPPRESS_UNUSED_WARNING(self);
    node_rx_t** rx = self->_lf_rx;
    int rx_width = self->_lf_rx_width; SUPPRESS_UNUSED_WARNING(rx_width);
    #line 56 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    // Acquire the GIL (Global Interpreter Lock) to be able to call Python APIs.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
    LF_PRINT_DEBUG("Calling reaction function Node.reaction_function_2");
    PyObject *rValue = PyObject_CallObject(
        self->_lf_py_reaction_function_2, 
        Py_BuildValue("(O)", convert_C_port_to_py(rx, rx_width))
    );
    if (rValue == NULL) {
        lf_print_error("FATAL: Calling reaction Node.reaction_function_2 failed.");
        if (PyErr_Occurred()) {
            PyErr_PrintEx(0);
            PyErr_Clear(); // this will reset the error indicator so we can run Python code again
        }
        /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
        Py_FinalizeEx();
        exit(1);
    }
    
    /* Release the thread. No Python API allowed beyond this point. */
    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);
}
#include "include/api/set_undef.h"
node_self_t* new_Node() {
    node_self_t* self = (node_self_t*)_lf_new_reactor(sizeof(node_self_t));
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.number = 0;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.function = nodereaction_function_0;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.self = self;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.STP_handler = NULL;
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.name = "?";
    #line 33 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_0.mode = NULL;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.number = 1;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.function = nodereaction_function_1;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.self = self;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.STP_handler = NULL;
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.name = "?";
    #line 44 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_1.mode = NULL;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.number = 2;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.function = nodereaction_function_2;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.self = self;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.STP_handler = NULL;
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.name = "?";
    #line 55 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__reaction_2.mode = NULL;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step.last = NULL;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #ifdef FEDERATED_DECENTRALIZED
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step.intended_tag = (tag_t) { .time = NEVER, .microstep = 0u};
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #endif // FEDERATED_DECENTRALIZED
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step_reactions[0] = &self->_lf__reaction_1;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step.reactions = &self->_lf__step_reactions[0];
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step.number_of_reactions = 1;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #ifdef FEDERATED
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__step.physical_time_of_arrival = NEVER;
    #line 21 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #endif // FEDERATED
    self->_lf__step.is_timer = true;
    #ifdef FEDERATED_DECENTRALIZED
    self->_lf__step.intended_tag = (tag_t) { .time = NEVER, .microstep = 0u};
    #endif // FEDERATED_DECENTRALIZED
    #ifdef FEDERATED_DECENTRALIZED
    self->_lf__startup.intended_tag = (tag_t) { .time = NEVER, .microstep = 0u};
    #endif // FEDERATED_DECENTRALIZED
    self->_lf__startup_reactions[0] = &self->_lf__reaction_0;
    self->_lf__startup.last = NULL;
    self->_lf__startup.reactions = &self->_lf__startup_reactions[0];
    self->_lf__startup.number_of_reactions = 1;
    self->_lf__startup.is_timer = false;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx.last = NULL;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #ifdef FEDERATED_DECENTRALIZED
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx.intended_tag = (tag_t) { .time = NEVER, .microstep = 0u};
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #endif // FEDERATED_DECENTRALIZED
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx_reactions[0] = &self->_lf__reaction_2;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx.reactions = &self->_lf__rx_reactions[0];
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx.number_of_reactions = 1;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #ifdef FEDERATED
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    self->_lf__rx.physical_time_of_arrival = NEVER;
    #line 22 "/home/fred/Lingua_Franca/Recover/Multi_input_FL/mi.lf"
    #endif // FEDERATED
    self->_lf__rx.tmplt.type.element_size = sizeof(PyObject);
    return self;
}
// =============== END reactor class Node
// =============== START reactor class mi
typedef struct {
    struct self_base_t base;
    char *_lf_name;
} mi_main_self_t;
mi_main_self_t* new_mi() {
    mi_main_self_t* self = (mi_main_self_t*)_lf_new_reactor(sizeof(mi_main_self_t));
    return self;
}
// =============== END reactor class mi
// Array of pointers to timer triggers to be scheduled in _lf_initialize_timers().
trigger_t* _lf_timer_triggers[6];
int _lf_timer_triggers_size = 6;
// Array of pointers to startup triggers.
reaction_t* _lf_startup_reactions[6];
int _lf_startup_reactions_size = 6;
// Array of pointers to shutdown triggers.
reaction_t** _lf_shutdown_reactions = NULL;
int _lf_shutdown_reactions_size = 0;
// Array of pointers to reset triggers.
reaction_t** _lf_reset_reactions = NULL;
int _lf_reset_reactions_size = 0;
void _lf_initialize_trigger_objects() {
    // Initialize the _lf_clock
    lf_initialize_clock();
    // Create the array that will contain pointers to is_present fields to reset on each step.
    _lf_is_present_fields_size = 36;
    _lf_is_present_fields = (bool**)calloc(36, sizeof(bool*));
    if (_lf_is_present_fields == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated = (bool**)calloc(36, sizeof(bool*));
    if (_lf_is_present_fields_abbreviated == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated_size = 0;
    #ifdef FEDERATED_DECENTRALIZED
    // Create the array that will contain pointers to intended_tag fields to reset on each step.
    _lf_intended_tag_fields_size = 36;
    _lf_intended_tag_fields = (tag_t**)malloc(_lf_intended_tag_fields_size * sizeof(tag_t*));
    
    #endif // FEDERATED_DECENTRALIZED
    int _lf_startup_reactions_count = 0;
    SUPPRESS_UNUSED_WARNING(_lf_startup_reactions_count);
    int _lf_shutdown_reactions_count = 0;
    SUPPRESS_UNUSED_WARNING(_lf_shutdown_reactions_count);
    int _lf_reset_reactions_count = 0;
    SUPPRESS_UNUSED_WARNING(_lf_reset_reactions_count);
    int _lf_timer_triggers_count = 0;
    SUPPRESS_UNUSED_WARNING(_lf_timer_triggers_count);
    int bank_index;
    SUPPRESS_UNUSED_WARNING(bank_index);
    mi_main_self_t* mi_main_self[1];
    SUPPRESS_UNUSED_WARNING(mi_main_self);
    node_self_t* mi_nodes_self[6];
    SUPPRESS_UNUSED_WARNING(mi_nodes_self);
    // ***** Start initializing mi of class mi
    mi_main_self[0] = new_mi();
    mi_main_self[0]->_lf_name = "mi_main_lf";
    // Reactor is a bank. Iterate over bank members.
    for (int mi_nodes_i = 0; mi_nodes_i < 6; mi_nodes_i++) {
        // ***** Start initializing mi.nodes of class Node
        mi_nodes_self[mi_nodes_i] = new_Node();
        mi_nodes_self[mi_nodes_i]->_lf_name = "mi_nodes_lf";
        mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_0 = 
        get_python_function("__main__", 
            mi_nodes_self[mi_nodes_i]->_lf_name,
            mi_nodes_i,
            "reaction_function_0");
        if(mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_0 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_0");
        }
        mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_1 = 
        get_python_function("__main__", 
            mi_nodes_self[mi_nodes_i]->_lf_name,
            mi_nodes_i,
            "reaction_function_1");
        if(mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_1 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_1");
        }
        mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_2 = 
        get_python_function("__main__", 
            mi_nodes_self[mi_nodes_i]->_lf_name,
            mi_nodes_i,
            "reaction_function_2");
        if(mi_nodes_self[mi_nodes_i]->_lf_py_reaction_function_2 == NULL) {
            lf_print_error_and_exit("Could not load function reaction_function_2");
        }
        mi_nodes_self[mi_nodes_i]->_lf_tx_width = 6;
        // Allocate memory for multiport output.
        mi_nodes_self[mi_nodes_i]->_lf_tx = (node_tx_t*)_lf_allocate(
                6, sizeof(node_tx_t),
                &mi_nodes_self[mi_nodes_i]->base.allocations); 
        mi_nodes_self[mi_nodes_i]->_lf_tx_pointers = (node_tx_t**)_lf_allocate(
                6, sizeof(node_tx_t*),
                &mi_nodes_self[mi_nodes_i]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 6; i++) {
                mi_nodes_self[mi_nodes_i]->_lf_tx_pointers[i] = &(mi_nodes_self[mi_nodes_i]->_lf_tx[i]);
        }
        mi_nodes_self[mi_nodes_i]->_lf_rx_width = 6;
        // Allocate memory for multiport inputs.
        mi_nodes_self[mi_nodes_i]->_lf_rx = (node_rx_t**)_lf_allocate(
                6, sizeof(node_rx_t*),
                &mi_nodes_self[mi_nodes_i]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 6; i++) {
            mi_nodes_self[mi_nodes_i]->_lf_rx[i] = &mi_nodes_self[mi_nodes_i]->_lf_default__rx;
        }
        _lf_startup_reactions[_lf_startup_reactions_count++] = &mi_nodes_self[mi_nodes_i]->_lf__reaction_0;
        // Initializing timer mi.nodes.step.
        mi_nodes_self[mi_nodes_i]->_lf__step.offset = 0;
        mi_nodes_self[mi_nodes_i]->_lf__step.period = SEC(1);
        _lf_timer_triggers[_lf_timer_triggers_count++] = &mi_nodes_self[mi_nodes_i]->_lf__step;
        mi_nodes_self[mi_nodes_i]->_lf__step.mode = NULL;
        mi_nodes_self[mi_nodes_i]->_lf__reaction_0.deadline = NEVER;
        mi_nodes_self[mi_nodes_i]->_lf__reaction_1.deadline = NEVER;
        mi_nodes_self[mi_nodes_i]->_lf__reaction_2.deadline = NEVER;
        //***** End initializing mi.nodes
    }
    //***** End initializing mi
    // **** Start deferred initialize for mi
    {
        // **** Start deferred initialize for mi.nodes
        // Reactor is a bank. Iterate over bank members.
        for (int mi_nodes_i = 0; mi_nodes_i < 6; mi_nodes_i++) {
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of mi.nodes.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of mi.nodes
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of mi.nodes.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.num_outputs = 6;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.triggers = (trigger_t***)_lf_allocate(
                    6, sizeof(trigger_t**),
                    &mi_nodes_self[mi_nodes_i]->base.allocations);
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.triggered_sizes = (int*)_lf_allocate(
                    6, sizeof(int),
                    &mi_nodes_self[mi_nodes_i]->base.allocations);
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.output_produced = (bool**)_lf_allocate(
                    6, sizeof(bool*),
                    &mi_nodes_self[mi_nodes_i]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    for (int i = 0; i < 6; i++) {
                        mi_nodes_self[mi_nodes_i]->_lf__reaction_1.output_produced[i + count]
                                = &mi_nodes_self[mi_nodes_i]->_lf_tx[i].is_present;
                    }
                    count += 6;
                }
            }
            
            // ** End initialization for reaction 1 of mi.nodes
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of mi.nodes.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of mi.nodes
        }
        // **** End of deferred initialize for mi.nodes
    }
    // **** End of deferred initialize for mi
    // **** Start non-nested deferred initialize for mi
    // **** Start non-nested deferred initialize for mi.nodes
    // For reference counting, set num_destinations for port mi.nodes.tx.
    // Iterate over range mi.nodes.tx(0,36)->[mi.nodes.rx(0,36)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 6, 6 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 36; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            SUPPRESS_UNUSED_WARNING(src_runtime);
            int src_channel = range_mr.digits[0]; // Channel index.
            SUPPRESS_UNUSED_WARNING(src_channel);
            int src_bank = range_mr.digits[1]; // Bank index.
            SUPPRESS_UNUSED_WARNING(src_bank);
            mi_nodes_self[src_runtime]->_lf_tx[src_channel].num_destinations = 6;
            mixed_radix_incr(&range_mr);
        }
    }
    {
        int triggers_index[6] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range mi.nodes.tx(0,36)->[mi.nodes.rx(0,36)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 6 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 36; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Reaction 1 of mi.nodes triggers 1 downstream reactions
                // through port mi.nodes.tx.
                mi_nodes_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of mi.nodes, allocate an
                // array of trigger pointers for downstream reactions through port mi.nodes.tx
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &mi_nodes_self[src_runtime]->base.allocations); 
                mi_nodes_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 6; i++) triggers_index[i] = 0;
        // Iterate over ranges mi.nodes.tx(0,36)->[mi.nodes.rx(0,36)] and mi.nodes.rx(0,36).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 6, 6 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range mi.nodes.rx(0,36).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 6, 6 };
                int permutation[] = { 1, 0 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 36; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(dst_runtime);
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(dst_channel);
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(dst_bank);
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Point to destination port mi.nodes.rx's trigger struct.
                    mi_nodes_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &mi_nodes_self[dst_runtime]->_lf__rx;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 36) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    // **** End of non-nested deferred initialize for mi.nodes
    // **** End of non-nested deferred initialize for mi
    // Connect inputs and outputs for reactor mi.
    // Connect inputs and outputs for reactor mi.nodes.
    // Connect mi.nodes.tx(0,36)->[mi.nodes.rx(0,36)] to port mi.nodes.rx(0,36)
    // Iterate over ranges mi.nodes.tx(0,36)->[mi.nodes.rx(0,36)] and mi.nodes.rx(0,36).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 6, 6 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range mi.nodes.rx(0,36).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 6, 6 };
            int permutation[] = { 1, 0 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 36; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                mi_nodes_self[dst_runtime]->_lf_rx[dst_channel] = (node_rx_t*)&mi_nodes_self[src_runtime]->_lf_tx[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 36) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Reactor is a bank. Iterate over bank members.
    for (int mi_nodes_i = 0; mi_nodes_i < 6; mi_nodes_i++) {
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        // Reactor is a bank. Iterate over bank members.
        for (int mi_nodes_i = 0; mi_nodes_i < 6; mi_nodes_i++) {
            // Add port mi.nodes.tx to array of is_present fields.
            // Port mi.nodes.tx is a multiport. Iterate over its channels.
            for (int mi_nodes_tx_c = 0; mi_nodes_tx_c < 6; mi_nodes_tx_c++) {
                _lf_is_present_fields[0 + count] = &mi_nodes_self[mi_nodes_i]->_lf_tx[mi_nodes_tx_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add port mi.nodes.tx to array of intended_tag fields.
                _lf_intended_tag_fields[0 + count] = &mi_nodes_self[mi_nodes_i]->_lf_tx[mi_nodes_tx_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    // Set reaction priorities for ReactorInstance mi
    {
        // Set reaction priorities for ReactorInstance mi.nodes
        // Reactor is a bank. Iterate over bank members.
        for (int mi_nodes_i = 0; mi_nodes_i < 6; mi_nodes_i++) {
            mi_nodes_self[mi_nodes_i]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_0.index = 0xffffffffffff0000LL;
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 1 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_1.index = 0xffffffffffff0001LL;
            mi_nodes_self[mi_nodes_i]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            mi_nodes_self[mi_nodes_i]->_lf__reaction_2.index = 0xffffffffffff0002LL;
        }
    }
    #ifdef EXECUTABLE_PREAMBLE
    _lf_executable_preamble();
    #endif
    #ifdef FEDERATED
    initialize_triggers_for_federate();
    #endif // FEDERATED
}
void _lf_trigger_startup_reactions() {
    for (int i = 0; i < _lf_startup_reactions_size; i++) {
        if (_lf_startup_reactions[i] != NULL) {
            _lf_trigger_reaction(_lf_startup_reactions[i], -1);
        }
    }
}
void _lf_initialize_timers() {
    for (int i = 0; i < _lf_timer_triggers_size; i++) {
        if (_lf_timer_triggers[i] != NULL) {
            _lf_initialize_timer(_lf_timer_triggers[i]);
        }
    }
}
void logical_tag_complete(tag_t tag_to_send) {
#ifdef FEDERATED_CENTRALIZED
        _lf_logical_tag_complete(tag_to_send);
#endif // FEDERATED_CENTRALIZED

}
bool _lf_trigger_shutdown_reactions() {
    return false;
}
#ifndef FEDERATED
void terminate_execution() {}
#endif
